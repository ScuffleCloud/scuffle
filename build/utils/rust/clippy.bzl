load("@rules_rust//rust:rust_common.bzl", "CrateInfo")
load("@rules_rust//rust/private:providers.bzl", "LintsInfo")
load("@rules_rust//rust/private:clippy.bzl", "ClippyFlagsInfo")
load(
    "@rules_rust//rust/private:rustc.bzl",
    "collect_deps",
    "collect_inputs",
    "construct_arguments",
)
load(
    "@rules_rust//rust/private:utils.bzl",
    "determine_output_hash",
    "find_cc_toolchain",
    "find_toolchain",
)

def _init_ClippyOutputInfo(files):
    return {
        "files": files,
        "_ClippyOutputInfo": "_ClippyOutputInfo",
    }

ClippyOutputInfo, _new_ClippyOutputInfo = provider(
    doc = "A set of clippy json diagnostics.",
    fields = {
        "_ClippyOutputInfo": "A tag to identify this provider by",
        "files": "A list of all the files generated by clippy",
    },
    init = _init_ClippyOutputInfo,
)

def _rust_clippy_rule_impl(ctx):
    toolchain = find_toolchain(ctx)
    cc_toolchain, feature_configuration = find_cc_toolchain(ctx)

    clippy_flags = [
        "--json=artifacts,diagnostic-rendered-ansi",
        "--cap-lints=warn",
    ]
    lint_files = []

    clippy_flags.extend(ctx.attr.clippy_flags)

    outputs = []

    for target in [ctx.attr._clippy_flag, ctx.attr._clippy_flags]:
        clippy_flags.extend(target[ClippyFlagsInfo].clippy_flags)

    if ctx.attr.lint_config:
        clippy_flags.extend(ctx.attr.lint_config[LintsInfo].clippy_lint_flags)
        clippy_flags.extend(ctx.attr.lint_config[LintsInfo].rustc_lint_flags)
        lint_files.extend(ctx.attr.lint_config[LintsInfo].clippy_lint_files)
        lint_files.extend(ctx.attr.lint_config[LintsInfo].rustc_lint_files)

    for target in ctx.attr.targets:
        crate_info = target[CrateInfo]
        dep_info, build_info, _ = collect_deps(
            deps = crate_info.deps,
            proc_macro_deps = crate_info.proc_macro_deps,
            aliases = crate_info.aliases,
        )

        compile_inputs, out_dir, build_env_files, build_flags_files, linkstamp_outs, ambiguous_libs = collect_inputs(
            ctx,
            ctx.file,
            ctx.files,
            # Clippy doesn't need to invoke transitive linking, therefore doesn't need linkstamps.
            depset([]),
            toolchain,
            cc_toolchain,
            feature_configuration,
            crate_info,
            dep_info,
            build_info,
            lint_files,
        )

        args, env = construct_arguments(
            ctx = ctx,
            attr = ctx.attr,
            file = ctx.file,
            toolchain = toolchain,
            tool_path = toolchain.clippy_driver.path,
            cc_toolchain = cc_toolchain,
            feature_configuration = feature_configuration,
            crate_info = crate_info,
            dep_info = dep_info,
            linkstamp_outs = linkstamp_outs,
            ambiguous_libs = ambiguous_libs,
            output_hash = determine_output_hash(crate_info.root, ctx.label),
            rust_flags = [],
            out_dir = out_dir,
            build_env_files = build_env_files,
            build_flags_files = build_flags_files,
            emit = ["dep-info", "metadata"],
            skip_expanding_rustc_env = True,
        )

        if crate_info.is_test:
            args.rustc_flags.add("--test")

        # For remote execution purposes, the clippy_out file must be a sibling of crate_info.output
        # or rustc may fail to create intermediate output files because the directory does not exist.
        clippy_out = ctx.actions.declare_file(ctx.label.name + ".clippy.out", sibling = crate_info.output)
        args.process_wrapper_flags.add("--stderr-file", clippy_out)
        args.process_wrapper_flags.add("--do-not-fail", "true")
        args.rustc_flags.add_all(clippy_flags)

        # Upstream clippy requires one of these two filenames or it silently uses
        # the default config. Enforce the naming so users are not confused.
        valid_config_file_names = [".clippy.toml", "clippy.toml"]
        if ctx.file._config.basename not in valid_config_file_names:
            fail("The clippy config file must be named one of: {}".format(valid_config_file_names))
        env["CLIPPY_CONF_DIR"] = "${{pwd}}/{}".format(ctx.file._config.dirname)
        inputs = depset([ctx.file._config], transitive = [compile_inputs])


        outputs.append(clippy_out)

        ctx.actions.run(
            executable = ctx.executable._process_wrapper,
            inputs = inputs,
            outputs = [clippy_out],
            env = env,
            tools = [toolchain.clippy_driver],
            arguments = args.all,
            mnemonic = "Clippy",
            progress_message = "Clippy %{label}",
            toolchain = "@rules_rust//rust:toolchain_type",
        )

    return [
        DefaultInfo(files = depset(outputs)),
        OutputGroupInfo(
            rust_clippy = outputs,
        ),
        ClippyOutputInfo(files = outputs),
    ]

rust_clippy = rule(
    fragments = ["cpp"],
    attrs = {
        "targets": attr.label_list(
            doc = "The targets to run clippy against.",
            providers = [CrateInfo],
        ),
        "lint_config": attr.label(
            doc = "A set of lints to use for clippy.",
            providers = [LintsInfo]
        ),
        "clippy_flags": attr.string_list(
            doc = "Additional flags to provide to clippy",
            default = ["-Dwarnings"],
        ),
        "_clippy_flag": attr.label(
            doc = "Arguments to pass to clippy." +
                  "Multiple uses are accumulated and appended after the extra_rustc_flags.",
            default = Label("@rules_rust//rust/settings:clippy_flag"),
        ),
        "_clippy_flags": attr.label(
            doc = "Arguments to pass to clippy",
            default = Label("@rules_rust//rust/settings:clippy_flags"),
        ),
        "_config": attr.label(
            doc = "The `clippy.toml` file used for configuration",
            allow_single_file = True,
            default = Label("@rules_rust//rust/settings:clippy.toml"),
        ),
        "_error_format": attr.label(
            doc = "The desired `--error-format` flags for clippy",
            default = "//build/utils/rust/clippy:error_format",
        ),
        "_extra_rustc_flag": attr.label(
            default = Label("@rules_rust//rust/settings:extra_rustc_flag"),
        ),
        "_per_crate_rustc_flag": attr.label(
            default = Label("@rules_rust//rust/settings:experimental_per_crate_rustc_flag"),
        ),
        "_process_wrapper": attr.label(
            doc = "A process wrapper for running clippy on all platforms",
            default = Label("@rules_rust//util/process_wrapper"),
            executable = True,
            cfg = "exec",
        ),
    },
    implementation = _rust_clippy_rule_impl,
    toolchains = [
        str(Label("@rules_rust//rust:toolchain_type")),
        "@bazel_tools//tools/cpp:toolchain_type",
    ],
    doc = """\
Executes the clippy checker on specified targets.

This aspect applies to existing rust_library, rust_test, and rust_binary rules.

As an example, if the following is defined in `examples/hello_lib/BUILD.bazel`:

```python
load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")

rust_library(
    name = "hello_lib",
    srcs = ["src/lib.rs"],
)

rust_test(
    name = "greeting_test",
    srcs = ["tests/greeting.rs"],
    deps = [":hello_lib"],
)

rust_clippy(
    name = "clippy_output",
    targets = [":hello_lib", ":greeting_test"],
)
```
""",
)


def _rust_clippy_test_impl(ctx):
    wrapper = ctx.actions.declare_file(ctx.label.name + "_" +  ctx.executable._clippy_test_runner.basename)
    ctx.actions.symlink(
        output = wrapper,
        target_file = ctx.executable._clippy_test_runner,
    )

    clippy_files = [file for target in ctx.attr.targets for file in target[ClippyOutputInfo].files]
    files = depset([wrapper])

    return [
        DefaultInfo(
            executable = wrapper,
            files = files,
            runfiles = ctx.runfiles(files = clippy_files),
        ),
        RunEnvironmentInfo(
            environment = {
                "CLIPPY_OUTPUTS": ";".join([file.short_path for file in clippy_files]),
            },
        ),
    ]

rust_clippy_test = rule(
    attrs = {
        "targets": attr.label_list(
            doc = "The set of clippy outputs to validate.",
            providers = [ClippyOutputInfo],
        ),
        "_clippy_test_runner": attr.label(
            doc = "A process wrapper for running clippy on all platforms",
            default = Label("//build/utils/rust/clippy:test_runner"),
            executable = True,
            cfg = "exec",
        ),
    },
    implementation = _rust_clippy_test_impl,
    test = True,
    doc = """\
Executes the clippy checker on specified targets.

This aspect applies to existing rust_library, rust_test, and rust_binary rules.

As an example, if the following is defined in `examples/hello_lib/BUILD.bazel`:

```python
load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")

rust_library(
    name = "hello_lib",
    srcs = ["src/lib.rs"],
)

rust_test(
    name = "greeting_test",
    srcs = ["tests/greeting.rs"],
    deps = [":hello_lib"],
)

rust_clippy_test(
    name = "clippy_test",
    targets = [":hello_lib", ":greeting_test"],
)
```
""",
)
