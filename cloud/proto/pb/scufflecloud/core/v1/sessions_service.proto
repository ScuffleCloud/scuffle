syntax = "proto3";

package scufflecloud.core.v1;

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "scufflecloud/core/v1/common.proto";
import "scufflecloud/core/v1/constraints.proto";
import "scufflecloud/core/v1/organizations.proto";
import "scufflecloud/core/v1/sessions.proto";
import "tinc/annotations.proto";

// Service for managing user sessions, including registration and login.
service SessionsService {
  rpc RegisterWithEmail(RegisterWithEmailRequest) returns (google.protobuf.Empty) {
    option (tinc.method).endpoint = {post: "/users"};
  }
  rpc CompleteRegisterWithEmail(CompleteRegisterWithEmailRequest) returns (NewUserSessionToken) {
    option (tinc.method).endpoint = {post: "/users/complete"};
  }

  rpc LoginWithEmailOptions(LoginWithEmailOptionsRequest) returns (LoginWithEmailOptionsResponse) {
    option (tinc.method).endpoint = {post: "/sessions/email"};
  }

  rpc LoginWithEmailAndPassword(LoginWithEmailAndPasswordRequest) returns (NewUserSessionToken) {
    option (tinc.method).endpoint = {post: "/sessions/email/password"};
  }

  rpc LoginWithMagicLink(LoginWithMagicLinkRequest) returns (google.protobuf.Empty) {
    option (tinc.method).endpoint = {post: "/sessions/email/magic-link"};
  }
  rpc CompleteLoginWithMagicLink(CompleteLoginWithMagicLinkRequest) returns (NewUserSessionToken) {
    option (tinc.method).endpoint = {post: "/sessions/email/magic-link/complete"};
  }

  rpc LoginWithGoogle(LoginWithGoogleRequest) returns (LoginWithGoogleResponse) {
    option (tinc.method).endpoint = {post: "/sessions/google"};
  }
  rpc CompleteLoginWithGoogle(CompleteLoginWithGoogleRequest) returns (CompleteLoginWithGoogleResponse) {
    option (tinc.method).endpoint = {post: "/sessions/google/complete"};
  }

  rpc LoginWithWebauthn(LoginWithWebauthnRequest) returns (NewUserSessionToken) {
    option (tinc.method).endpoint = {post: "/sessions/webauthn"};
  }

  rpc CreateUserSessionRequest(CreateUserSessionRequestRequest) returns (UserSessionRequest) {
    option (tinc.method).endpoint = {post: "/session-requests"};
  }
  rpc GetUserSessionRequest(GetUserSessionRequestRequest) returns (UserSessionRequest) {
    option (tinc.method).endpoint = {get: "/session-requests/{id}"};
  }
  rpc GetUserSessionRequestByCode(GetUserSessionRequestByCodeRequest) returns (UserSessionRequest) {
    option (tinc.method).endpoint = {get: "/session-requests/code/{code}"};
  }
  rpc ApproveUserSessionRequestByCode(ApproveUserSessionRequestByCodeRequest) returns (UserSessionRequest) {
    option (tinc.method).endpoint = {patch: "/session-requests/code/{code}/approve"};
  }
  rpc CompleteUserSessionRequest(CompleteUserSessionRequestRequest) returns (NewUserSessionToken) {
    option (tinc.method).endpoint = {post: "/session-requests/{id}/complete"};
  }

  // Validate the current session with MFA.
  rpc ValidateMfaForUserSession(ValidateMfaForUserSessionRequest) returns (UserSession) {
    option (tinc.method).endpoint = {post: "/sessions/mfa"};
  }
  // Refresh the current session.
  // Returns a new session token and invalidates the current one.
  rpc RefreshUserSession(google.protobuf.Empty) returns (NewUserSessionToken) {
    option (tinc.method).endpoint = {put: "/sessions/refresh"};
  }
  // Deletes the current session.
  rpc InvalidateUserSession(google.protobuf.Empty) returns (google.protobuf.Empty) {
    option (tinc.method).endpoint = {delete: "/sessions"};
  }
}

enum DeviceAlgorithm {
  // RSA with OAEP padding and SHA-256 hashing.
  RSA_OAEP_SHA256 = 0;
}

message Device {
  // The crypto algorithm (e.g. RSA) used for the public key.
  DeviceAlgorithm algorithm = 1;
  // Public key data in SPKI format.
  bytes public_key_data = 2;
}

enum MfaOption {
  MFA_OPTION_UNSPECIFIED = 0 [(tinc.variant).visibility = SKIP];
  MFA_OPTION_TOTP = 1;
  MFA_OPTION_WEB_AUTHN = 2;
  MFA_OPTION_RECOVERY_CODES = 3;
}

message NewUserSessionToken {
  string id = 1 [(string_constraint).id = true];
  bytes encrypted_token = 2;
  google.protobuf.Timestamp expires_at = 3;
  string user_id = 4 [(string_constraint).id = true];
  bool session_mfa_pending = 5;
  repeated MfaOption mfa_options = 6;
}

message RegisterWithEmailRequest {
  CaptchaChallengeResponse captcha = 1;
  // The email address to register with.
  string email = 2 [(tinc.field).constraint.string.email = true];
}

message CompleteRegisterWithEmailRequest {
  // The code received via email.
  bytes code = 1;
  Device device = 2;
}

message LoginWithEmailOptionsRequest {
  CaptchaChallengeResponse captcha = 1;
  string email = 2 [(tinc.field).constraint.string.email = true];
}

enum LoginWithEmailOptions {
  PASSWORD = 0;
  MAGIC_LINK = 1;
  WEBAUTHN = 2;
}

message LoginWithEmailOptionsResponse {
  repeated LoginWithEmailOptions options = 1;
}

message LoginWithEmailAndPasswordRequest {
  CaptchaChallengeResponse captcha = 1;
  string email = 2 [(tinc.field).constraint.string.email = true];
  string password = 3 [(string_constraint).password = true];
  Device device = 4;
}

message LoginWithMagicLinkRequest {
  CaptchaChallengeResponse captcha = 1;
  string email = 2 [(tinc.field).constraint.string.email = true];
}

message CompleteLoginWithMagicLinkRequest {
  bytes code = 1;
  Device device = 2;
}

message LoginWithGoogleRequest {
  // The device is only used to generate a state parameter, it is not saved and
  // should therefore be sent again on the complete request.
  Device device = 1;
}

message LoginWithGoogleResponse {
  string authorization_url = 1;
}

message CompleteLoginWithGoogleRequest {
  // The code returned by Google after the user has authorized the application.
  string code = 1;
  string state = 2;
  Device device = 3;
}

message CompleteLoginWithGoogleResponse {
  NewUserSessionToken new_user_session_token = 1;
  bool first_login = 2;
  oneof google_workspace {
    // This is present if the user just joined a Google Workspace organization by logging in.
    Organization joined = 3;
    // This is present if the user is an admin of a Google Workspace that has not been associated with an organization yet.
    // The user should be offered the option to create the organization after this.
    string unassociated_google_hosted_domain = 4;
  }
}

message LoginWithWebauthnRequest {
  string user_id = 1 [(string_constraint).id = true];
  // JSON encoded
  // https://docs.rs/webauthn-rs/latest/webauthn_rs/prelude/struct.PublicKeyCredential.html
  string response_json = 2;
  Device device = 3;
}

message CreateUserSessionRequestRequest {
  string name = 1;
}

message UserSessionRequest {
  string id = 1 [(string_constraint).id = true];
  string name = 2;
  string ip = 3;
  optional string approved_by = 4 [(string_constraint).id = true];
  google.protobuf.Timestamp expires_at = 5;
}

message GetUserSessionRequestRequest {
  string id = 1 [(string_constraint).id = true];
}

message GetUserSessionRequestByCodeRequest {
  string code = 1 [(tinc.field).constraint.string.len = 6];
}

message ApproveUserSessionRequestByCodeRequest {
  string code = 1 [(tinc.field).constraint.string.len = 6];
}

message CompleteUserSessionRequestRequest {
  string id = 1 [(string_constraint).id = true];
  Device device = 2;
}

message ValidateMfaForUserSessionTotp {
  string code = 1 [(tinc.field).constraint.string.len = 6];
}

message ValidateMfaForUserSessionWebauthn {
  // JSON encoded
  // https://docs.rs/webauthn-rs/latest/webauthn_rs/prelude/struct.PublicKeyCredential.html
  string response_json = 1;
}

message ValidateMfaForUserSessionRecoveryCode {
  string code = 1 [(tinc.field).constraint.string.len = 8];
}

message ValidateMfaForUserSessionRequest {
  oneof response {
    ValidateMfaForUserSessionTotp totp = 1;
    ValidateMfaForUserSessionWebauthn webauthn = 2;
    ValidateMfaForUserSessionRecoveryCode recovery_code = 3;
  }
}
