syntax = "proto3";

package scufflecloud.core.v1;

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "tinc/annotations.proto";

import "scufflecloud/core/v1/common.proto";
import "scufflecloud/core/v1/constraints.proto";
import "scufflecloud/core/v1/sessions.proto";
import "scufflecloud/core/v1/organizations.proto";

service SessionsService {
    rpc RegisterWithEmail(RegisterWithEmailRequest) returns (google.protobuf.Empty) {
        option (tinc.method).endpoint = {
            post: "/users"
        };
    }
    rpc CompleteRegisterWithEmail(CompleteRegisterWithEmailRequest) returns (NewUserSessionToken) {
        option (tinc.method).endpoint = {
            post: "/users/complete"
        };
    }

    rpc LoginWithEmailOptions(LoginWithEmailOptionsRequest) returns (LoginWithEmailOptionsResponse) {
        option (tinc.method).endpoint = {
            post: "/sessions/email"
        };
    }

    rpc LoginWithEmailAndPassword(LoginWithEmailAndPasswordRequest) returns (NewUserSessionToken) {
        option (tinc.method).endpoint = {
            post: "/sessions/email/password"
        };
    }

    rpc LoginWithMagicLink(LoginWithMagicLinkRequest) returns (google.protobuf.Empty) {
        option (tinc.method).endpoint = {
            post: "/sessions/email/magic-link"
        };
    }
    rpc CompleteLoginWithMagicLink(CompleteLoginWithMagicLinkRequest) returns (NewUserSessionToken) {
        option (tinc.method).endpoint = {
            post: "/sessions/email/magic-link/complete"
        };
    }

    rpc LoginWithGoogle(LoginWithGoogleRequest) returns (LoginWithGoogleResponse) {
        option (tinc.method).endpoint = {
            post: "/sessions/google"
        };
    }
    rpc CompleteLoginWithGoogle(CompleteLoginWithGoogleRequest) returns (CompleteLoginWithGoogleResponse) {
        option (tinc.method).endpoint = {
            post: "/sessions/google/complete"
        };
    }

    rpc LoginWithWebauthnPublicKey(LoginWithWebauthnPublicKeyRequest) returns (NewUserSessionToken) {
        option (tinc.method).endpoint = {
            post: "/sessions/webauthn"
        };
    }

    rpc CreateUserSessionRequest(CreateUserSessionRequestRequest) returns (UserSessionRequest) {
        option (tinc.method).endpoint = {
            post: "/session-requests"
        };
    }
    rpc GetUserSessionRequest(GetUserSessionRequestRequest) returns (UserSessionRequest) {
        option (tinc.method).endpoint = {
            get: "/session-requests/{id}"
        };
    }
    rpc GetUserSessionRequestByCode(GetUserSessionRequestByCodeRequest) returns (UserSessionRequest) {
        option (tinc.method).endpoint = {
            get: "/session-requests/code/{code}"
        };
    }
    rpc ApproveUserSessionRequestByCode(ApproveUserSessionRequestByCodeRequest) returns (UserSessionRequest) {
        option (tinc.method).endpoint = {
            patch: "/session-requests/code/{code}/approve"
        };
    }
    rpc CompleteUserSessionRequest(CompleteUserSessionRequestRequest) returns (NewUserSessionToken) {
        option (tinc.method).endpoint = {
            post: "/session-requests/{id}/complete"
        };
    }

    // Validate the current session with MFA.
    rpc ValidateMfaForUserSession(ValidateMfaForUserSessionRequest) returns (UserSession) {
        option (tinc.method).endpoint = {
            post: "/sessions/mfa"
        };
    }
    // Refresh the current session.
    // Returns a new session token and invalidates the current one.
    rpc RefreshUserSession(google.protobuf.Empty) returns (NewUserSessionToken) {
        option (tinc.method).endpoint = {
            put: "/sessions/refresh"
        };
    }
    // Deletes the current session.
    rpc InvalidateUserSession(google.protobuf.Empty) returns (google.protobuf.Empty) {
        option (tinc.method).endpoint = {
            delete: "/sessions"
        };
    }
}

enum DeviceAlgorithm {
    // RSA with OAEP padding and SHA-256 hashing.
    RSA_OAEP_SHA256 = 0;
}

message Device {
    // The crypto algorithm (e.g. RSA) used for the public key.
    DeviceAlgorithm algorithm = 1;
    // Public key data in PKCS#8 DER format.
    bytes public_key_data = 2;
}

enum MfaOption {
    TOTP = 0;
    WEB_AUTHN = 1;
}

message NewUserSessionToken {
    string id = 1 [(string_constraint).id = true];
    bytes encrypted_token = 2;
    google.protobuf.Timestamp expires_at = 3;
    bool session_mfa_pending = 4;
    repeated MfaOption mfa_options = 5;
}

message RegisterWithEmailRequest {
    CaptchaChallengeResponse captcha = 1;
    // The email address to register with.
    string email = 2 [(tinc.field).constraint.string.email = true];
}

message CompleteRegisterWithEmailRequest {
    // The code received via email.
    bytes code = 1;
    Device device = 2;
}

message LoginWithEmailOptionsRequest {
    CaptchaChallengeResponse captcha = 1;
    string email = 2 [(tinc.field).constraint.string.email = true];
}

enum LoginWithEmailOptions {
    PASSWORD = 0;
    MAGIC_LINK = 1;
}

message LoginWithEmailOptionsResponse {
    repeated LoginWithEmailOptions options = 1;
}

message LoginWithEmailAndPasswordRequest {
    CaptchaChallengeResponse captcha = 1;
    string email = 2 [(tinc.field).constraint.string.email = true];
    string password = 3 [(string_constraint).password = true];
    Device device = 4;
}

message LoginWithMagicLinkRequest {
    CaptchaChallengeResponse captcha = 1;
    string email = 2 [(tinc.field).constraint.string.email = true];
}

message CompleteLoginWithMagicLinkRequest {
    bytes code = 1;
    Device device = 2;
}

message LoginWithGoogleRequest {
    // The device is only used to generate a state parameter, it is not saved and
    // should therefore be sent again on the complete request.
    Device device = 1;
}

message LoginWithGoogleResponse {
    string authorization_url = 1;
}

message CompleteLoginWithGoogleRequest {
    // The code returned by Google after the user has authorized the application.
    string code = 1;
    string state = 2;
    Device device = 3;
}

message CompleteLoginWithGoogleResponse {
    NewUserSessionToken new_user_session_token = 1;
    bool first_login = 2;
    oneof google_workspace {
        // This is present if the user just joined a Google Workspace organization by logging in.
        Organization joined = 3;
        // This is present if the user is an admin of a Google Workspace that has not been associated with an organization yet.
        // The user should be offered the option to create the organization after this.
        string unassociated_google_hosted_domain = 4;
    }
}

// https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential
message LoginWithWebauthnPublicKeyRequest {
    bytes credential_id = 1;
    AuthenticatorAssertionResponse response = 2;
    Device device = 3;
}

// https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAssertionResponse
// https://w3c.github.io/webauthn/#iface-authenticatorassertionresponse
message AuthenticatorAssertionResponse {
    bytes client_data_json = 1;
    bytes authenticator_data = 2;
    bytes signature = 3;
}

message CreateUserSessionRequestRequest {
    string name = 1;
}

message UserSessionRequest {
    string id = 1 [(string_constraint).id = true];
    string name = 2;
    string ip = 3;
    optional string approved_by = 4 [(string_constraint).id = true];
    google.protobuf.Timestamp expires_at = 5;
}

message GetUserSessionRequestRequest {
    string id = 1 [(string_constraint).id = true];
}

message GetUserSessionRequestByCodeRequest {
    string code = 1 [(tinc.field).constraint.string.len = 6];
}

message ApproveUserSessionRequestByCodeRequest {
    string code = 1 [(tinc.field).constraint.string.len = 6];
}

message CompleteUserSessionRequestRequest {
    string id = 1 [(string_constraint).id = true];
    Device device = 2;
}

message ValidateMfaForUserSessionWebauthn {
    bytes credential_id = 1;
    AuthenticatorAssertionResponse response = 2;
}

message ValidateMfaForUserSessionTotp {
    string code = 1 [(tinc.field).constraint.string.len = 6];
}

message ValidateMfaForUserSessionRequest {
    oneof response {
        ValidateMfaForUserSessionWebauthn webauthn = 1;
        ValidateMfaForUserSessionTotp totp = 2;
    }
}
