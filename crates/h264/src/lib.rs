//! A pure Rust implementation of the H.264 (header only) builder and parser.
//!
//! This crate is designed to provide a simple and safe interface to build and parse H.264 headers.
#![cfg_attr(feature = "docs", doc = "\n\nSee the [changelog][changelog] for a full release history.")]
#![cfg_attr(feature = "docs", doc = "## Feature flags")]
#![cfg_attr(feature = "docs", doc = document_features::document_features!())]
//! ## Examples
//!
//! ### Parsing
//!
//! ```rust
//! use std::io;
//!
//! use scuffle_bytes_util::zero_copy::Deserialize;
//!
//! use scuffle_h264::{AVCDecoderConfigurationRecord, Sps};
//!
//! // A sample h264 bytestream to parse
//! # let bytes = b"\x01d\0\x1f\xff\xe1\0\x17\x67\x64\x00\x1F\xAC\xD9\x41\xE0\x6D\xF9\xE6\xA0\x20\x20\x28\x00\x00\x00\x08\x00\x00\x01\xE0\x01\0\x06h\xeb\xe3\xcb\"\xc0\xfd\xf8\xf8\0";
//!
//! // Parsing
//! let result = AVCDecoderConfigurationRecord::deserialize(scuffle_bytes_util::zero_copy::Slice::from(&bytes[..])).unwrap();
//!
//! // Do something with it!
//!
//! // You can also parse an Sps from the Sps struct:
//! let sps = Sps::parse_with_emulation_prevention(io::Cursor::new(&result.sps[0]));
//! ```
//!
//! For more examples, check out the tests in the source code for the parse function.
//!
//! ### Building
//!
//! ```rust
//! use scuffle_bytes_util::BytesCow;
//! use scuffle_bytes_util::zero_copy::Serialize;
//!
//! use scuffle_h264::{AVCDecoderConfigurationRecord, AvccExtendedConfig, Sps, SpsExtended};
//!
//! let extended_config = AvccExtendedConfig {
//!     chroma_format_idc: 1,
//!     bit_depth_luma_minus8: 0,
//!     bit_depth_chroma_minus8: 0,
//!     sequence_parameter_set_ext: vec![SpsExtended {
//!         chroma_format_idc: 1,
//!         separate_color_plane_flag: false,
//!         bit_depth_luma_minus8: 2,
//!         bit_depth_chroma_minus8: 3,
//!         qpprime_y_zero_transform_bypass_flag: false,
//!         scaling_matrix: vec![],
//!     }],
//! };
//! let config = AVCDecoderConfigurationRecord {
//!     configuration_version: 1,
//!     profile_indication: 100,
//!     profile_compatibility: 0,
//!     level_indication: 31,
//!     length_size_minus_one: 3,
//!     sps: vec![
//!         BytesCow::from_static(b"spsdata"),
//!     ],
//!     pps: vec![BytesCow::from_static(b"ppsdata")],
//!     extended_config: Some(extended_config),
//! };
//!
//! // Creating a buffer to store the built bytestream
//! let mut built = Vec::new();
//!
//! // Building
//! config.serialize(&mut built).unwrap();
//!
//! // Do something with it!
//! ```
//!
//! For more examples, check out the tests in the source code for the build function.
//!
//! ## License
//!
//! This project is licensed under the MIT or Apache-2.0 license.
//! You can choose between one of them if you use this work.
//!
//! `SPDX-License-Identifier: MIT OR Apache-2.0`
#![cfg_attr(all(coverage_nightly, test), feature(coverage_attribute))]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![deny(missing_docs)]
#![deny(unsafe_code)]
#![deny(unreachable_pub)]

pub mod boxes;
mod config;
mod enums;
mod sps;

pub use enums::*;
pub use sps::*;

pub use self::config::{AVCDecoderConfigurationRecord, AvccExtendedConfig};

/// Changelogs generated by [scuffle_changelog]
#[cfg(feature = "docs")]
#[scuffle_changelog::changelog]
pub mod changelog {}
