//! An HTTP server with support for HTTP/1, HTTP/2 and HTTP/3.
//!
//! It abstracts away [`hyper`](https://crates.io/crates/hyper) and [`h3`](https://crates.io/crates/h3) to provide a rather simple interface for creating and running a server that can handle all three protocols.
//!
//! See the [examples](./examples) directory for usage examples.
#![cfg_attr(feature = "docs", doc = "\n\nSee the [changelog][changelog] for a full release history.")]
#![cfg_attr(feature = "docs", doc = "## Feature flags")]
#![cfg_attr(feature = "docs", doc = document_features::document_features!())]
//! ## Why do we need this?
//!
//! This crate is designed to be a simple and easy to use HTTP server that supports HTTP/1, HTTP/2 and HTTP/3.
//!
//! Currently, there are simply no other crates that provide support for all three protocols with a unified API.
//! This crate aims to fill that gap.
//!
//! ## Example
//!
//! The following example demonstrates how to create a simple HTTP server (without TLS) that responds with "Hello, world!" to all requests on port 3000.
//!
//! ```rust
//! # use scuffle_future_ext::FutureExt;
//! # tokio_test::block_on(async {
//! # let run = async {
//! let service = scuffle_http::service::fn_http_service(|req| async move {
//!     scuffle_http::Response::builder()
//!         .status(scuffle_http::http::StatusCode::OK)
//!         .header(scuffle_http::http::header::CONTENT_TYPE, "text/plain")
//!         .body("Hello, world!".to_string())
//! });
//! let service_factory = scuffle_http::service::service_clone_factory(service);
//!
//! scuffle_http::HttpServer::builder()
//!     .service_factory(service_factory)
//!     .bind("[::]:3000".parse().unwrap())
//!     .build()
//!     .run()
//!     .await
//!     .expect("server failed");
//! # };
//! # run.with_timeout(std::time::Duration::from_secs(1)).await.expect_err("test should have timed out");
//! # });
//! ```
//!
//! ### Missing Features
//!
//! - HTTP/3 webtransport support
//! - Upgrading to websocket connections from HTTP/3 connections (this is usually done via HTTP/1.1 anyway)
//!
//! ## License
//!
//! This project is licensed under the MIT or Apache-2.0 license.
//! You can choose between one of them if you use this work.
//!
//! `SPDX-License-Identifier: MIT OR Apache-2.0`
#![cfg_attr(all(coverage_nightly, test), feature(coverage_attribute))]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![deny(missing_docs)]
#![deny(unsafe_code)]
#![deny(unreachable_pub)]
#![deny(clippy::mod_module_files)]

#[cfg(all(feature = "http3", not(feature = "tls-rustls")))]
compile_error!("feature \"tls-rustls\" must be enabled when \"http3\" is enabled.");

#[cfg(any(feature = "http1", feature = "http2", feature = "http3"))]
pub mod backend;
pub mod body;
pub mod error;
pub mod extensions;
mod server;
pub mod service;
mod tests;

pub use http;
pub use http::Response;
pub use server::{HttpServer, HttpServerBuilder};

/// An incoming request.
pub type IncomingRequest = http::Request<body::IncomingBody>;

/// Changelogs generated by [scuffle_changelog]
#[cfg(feature = "docs")]
#[scuffle_changelog::changelog]
pub mod changelog {}
