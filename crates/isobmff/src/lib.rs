//! Implementation of the ISO Base Media File Format (ISOBMFF) defined by ISO/IEC 14496-12.
//!
//! ## Example
//!
//! ```rust
//! ```
//!
//! ## Notes
//!
//! This implementation does not preserve the order of boxes when remuxing files and individual boxes.
//! Instead it uses the recommended box order as defined in ISO/IEC 14496-12 - 6.3.4.
#![cfg_attr(feature = "docs", doc = "\n\nSee the [changelog][changelog] for a full release history.")]
#![cfg_attr(feature = "docs", doc = "## Feature flags")]
#![cfg_attr(feature = "docs", doc = document_features::document_features!())]
//! ## License
//!
//! This project is licensed under the [MIT](./LICENSE.MIT) or [Apache-2.0](./LICENSE.Apache-2.0) license.
//! You can choose between one of them if you use this work.
//!
//! `SPDX-License-Identifier: MIT OR Apache-2.0`
#![cfg_attr(all(coverage_nightly, test), feature(coverage_attribute))]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
// #![deny(missing_docs)]
#![deny(unsafe_code)]
#![deny(unreachable_pub)]

use std::fmt::Debug;
use std::io;

use scuffle_bytes_util::BytesCow;
use scuffle_bytes_util::zero_copy::{Deserialize, DeserializeSeed, Serialize};

pub mod boxes;
mod common_types;
mod conformance_tests;
mod file;
mod header;
mod sized;
mod utils;

pub use common_types::*;
pub use file::*;
pub use header::*;
pub use isobmff_derive::IsoBox;
pub use sized::*;

#[doc(hidden)]
pub mod reexports {
    pub use scuffle_bytes_util;
}

/// Changelogs generated by [scuffle_changelog]
#[cfg(feature = "docs")]
#[scuffle_changelog::changelog]
pub mod changelog {}

/// This trait should be implemented by all box types.
pub trait IsoBox: IsoSized {
    /// The box type of this box.
    const TYPE: BoxType;

    /// This function calculates the header size, adds it to the given payload size and return the result.
    ///
    /// This can be used as a helper function when implementing the [`IsoSized`] trait.
    fn add_header_size(payload_size: usize) -> usize {
        let mut box_size = payload_size;
        box_size += 4 + 4; // size + type
        if let BoxType::Uuid(_) = Self::TYPE {
            box_size += 16; // usertype
        }

        // If the size does not fit in a u32 we use a long size.
        if box_size > u32::MAX as usize {
            box_size += 8; // large size
        }

        box_size
    }

    /// Constructs a [`BoxHeader`] for this box.
    fn box_header(&self) -> BoxHeader {
        BoxHeader {
            size: self.size().into(),
            box_type: Self::TYPE,
        }
    }

    /// Serializes the box header returned by [`IsoBox::box_header`] to the given writer.
    fn serialize_box_header<W>(&self, writer: W) -> std::io::Result<()>
    where
        W: std::io::Write,
    {
        self.box_header().serialize(writer)
    }
}

/// Any unknown box.
///
/// Can be used whenever the type is not known.
///
/// Use [`UnknownBox::try_from_box`] to create an [`UnknownBox`] from a known box type and
/// [`UnknownBox::deserialize_as_box`] to deserialize it into a specific box type.
#[derive(PartialEq, Eq)]
pub struct UnknownBox<'a> {
    /// The header of the box.
    pub header: BoxHeader,
    /// The payload data of the box.
    pub data: BytesCow<'a>,
}

impl Debug for UnknownBox<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UnknownBox")
            .field("header", &self.header)
            .field("data.len", &self.data.len())
            .finish()
    }
}

impl<'a> Deserialize<'a> for UnknownBox<'a> {
    fn deserialize<R>(mut reader: R) -> std::io::Result<Self>
    where
        R: scuffle_bytes_util::zero_copy::ZeroCopyReader<'a>,
    {
        let header = BoxHeader::deserialize(&mut reader)?;
        Self::deserialize_seed(&mut reader, header)
    }
}

impl<'a> DeserializeSeed<'a, BoxHeader> for UnknownBox<'a> {
    fn deserialize_seed<R>(mut reader: R, seed: BoxHeader) -> std::io::Result<Self>
    where
        R: scuffle_bytes_util::zero_copy::ZeroCopyReader<'a>,
    {
        Ok(Self {
            header: seed,
            data: reader.try_read_to_end()?,
        })
    }
}

impl Serialize for UnknownBox<'_> {
    fn serialize<W>(&self, mut writer: W) -> std::io::Result<()>
    where
        W: std::io::Write,
    {
        self.header.serialize(&mut writer)?;
        self.data.serialize(&mut writer)?;
        Ok(())
    }
}

impl<'a> UnknownBox<'a> {
    /// Creates an [`UnknownBox`] from a known box type.
    pub fn try_from_box(box_: impl IsoBox + Serialize) -> Result<Self, io::Error> {
        #[derive(Debug)]
        struct SkipWriter<W> {
            writer: W,
            skip_size: usize,
        }

        impl<W> io::Write for SkipWriter<W>
        where
            W: io::Write,
        {
            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                // Calculate how many bytes are left to skip
                let skip = self.skip_size.min(buf.len());

                // Write the data and skip the specified number of bytes
                // n is the number of bytes that were actually written considering the skip
                let n = self.writer.write(&buf[skip..])? + skip;
                // Update the counter
                self.skip_size = self.skip_size.saturating_sub(n);
                Ok(n)
            }

            fn flush(&mut self) -> io::Result<()> {
                self.writer.flush()
            }
        }

        let header = box_.box_header();

        let mut data = if let Some(size) = header.payload_size() {
            Vec::with_capacity(size)
        } else {
            Vec::new()
        };
        box_.serialize(SkipWriter {
            writer: &mut data,
            skip_size: header.size(),
        })?;

        data.shrink_to_fit();

        Ok(Self {
            header,
            data: data.into(),
        })
    }

    /// Deserializes the box as a specific type.
    pub fn deserialize_as<T, S>(self) -> std::io::Result<T>
    where
        T: DeserializeSeed<'a, S>,
        S: DeserializeSeed<'a, BoxHeader>,
    {
        let mut reader = scuffle_bytes_util::zero_copy::BytesBuf::from(self.data.into_bytes());
        let seed = S::deserialize_seed(&mut reader, self.header)?;
        T::deserialize_seed(&mut reader, seed)
    }

    /// Deserializes the box as a specific type, which implements [`IsoBox`].
    pub fn deserialize_as_box<B>(self) -> std::io::Result<B>
    where
        B: IsoBox + Deserialize<'a>,
    {
        if self.header.box_type != B::TYPE {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Box type mismatch: expected {:?}, found {:?}", B::TYPE, self.header.box_type),
            ));
        }

        let reader = scuffle_bytes_util::zero_copy::BytesBuf::from(self.data.into_bytes());
        B::deserialize(reader)
    }
}

impl IsoSized for UnknownBox<'_> {
    fn size(&self) -> usize {
        self.header.size() + self.data.size()
    }
}
