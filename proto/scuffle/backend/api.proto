syntax = "proto3";

package scuffle.backend;

import "scuffle/types/stream_variant.proto";

// This is an internal API for the Scuffle service.
// Used for communication between scuffle microservices.
service API {
  // Method used by Ingest service to validate a stream key when a new publisher
  // goes live.
  rpc AuthenticateLiveStream(AuthenticateLiveStreamRequest)
      returns (AuthenticateLiveStreamResponse) {}

  // Method used by the Ingest service to create a new stream.
  // Only called if try_resumed is true and the stream could not be resumed.
  rpc NewLiveStream(NewLiveStreamRequest) returns (NewLiveStreamResponse) {}

  // Method is used by the Ingest, Transcoder and Edge services, transcoder uses
  // it to publish the variants and edge uses it to update the state of the
  // stream (if it is ready to be played) and Ingest will use it to handle when
  // the stream is stopped.
  rpc UpdateLiveStream(UpdateLiveStreamRequest)
      returns (UpdateLiveStreamResponse) {}
}

// This request is created by the Ingest service when a new publisher goes live.
message AuthenticateLiveStreamRequest {
  // The name of the app that the publisher is trying to go live on.
  string app_name = 1;
  // The stream key that the publisher is trying to go live with.
  string stream_key = 2;
  // The IP address of the publisher.
  string ip_address = 3;
  // Address of the ingest server which the publisher is connected to.
  string ingest_address = 4;
  // The connection ID of the publisher.
  string connection_id = 5;
}

// This response is sent back to the Ingest service, generated by the API
// service.
message AuthenticateLiveStreamResponse {
  // A new stream ID to use for the stream.
  string stream_id = 2;
  // Whether the stream should be transcoded or not.
  bool transcode = 3;
  // should record the stream
  bool record = 4;
  // Try resume the live stream using the variants from the previous stream.
  // If the stream was not stopped properly, this will be true.
  // If its not possible to resume the stream, ingest should call NewLiveStream
  // to create a new stream.
  bool try_resume = 5;
  // The variants of the stream. (if the stream was resumed)
  repeated scuffle.types.StreamVariant variants = 6;
}

// This request is created by the Ingest service when we attempt to resume a
// stream and it fails.
message NewLiveStreamRequest {
  // The ID of the stream to create.
  string old_stream_id = 1;
  // The new variants of the stream.
  repeated scuffle.types.StreamVariant variants = 2;
}

// This response is sent back to the Ingest service, generated by the API
message NewLiveStreamResponse {
  // The ID of the stream that was created.
  string stream_id = 1;
}

enum LiveStreamState {
  NOT_READY = 0;
  READY = 1;
  STOPPED = 2;
  STOPPED_RESUMABLE = 3;
  FAILED = 4;
}

message UpdateLiveStreamRequest {
  // The ID of the stream to update.
  string stream_id = 1;

  string connection_id = 2;

  // Once transcoding starts this message will be sent to the API service.
  message Variants {
    repeated scuffle.types.StreamVariant variants = 1;
  }

  // If the stream is ready or has stopped, this message will be sent.

  // If the stream failed, this message will be sent.
  message Event {
    enum Level {
      INFO = 0;
      WARNING = 1;
      ERROR = 2;
    }

    // The title of the event.
    string title = 1;
    // The message in the event.
    string message = 2;
    // The level of the event
    Level level = 3;
  }

  message Bitrate {
    // The bitrate of the stream.
    uint64 video_bitrate = 1;
    uint64 audio_bitrate = 2;
    uint64 metadata_bitrate = 3;
  }

  // We only need oneof these fields to be set.
  message Update {
    uint64 timestamp = 1;
    oneof update {
      Variants variants = 2;
      LiveStreamState state = 3;
      Bitrate bitrate = 4;
      Event event = 5;
    }
  }

  repeated Update updates = 3;
}

message UpdateLiveStreamResponse {}
